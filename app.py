from google import genai
from linebot import LineBotApi, WebhookHandler
from linebot.models import (
    TextSendMessage, MessageEvent, TextMessage,
    FlexSendMessage
)
from flask import Flask, request, abort
from datetime import datetime
import random

# === LINE API Token ‡πÅ‡∏•‡∏∞ Secret ===
CHANNEL_ACCESS_TOKEN = 'Oz6x3Zse8dmKO5HWmiRy3aCa26v1aiRJWAFIcGXp/kvSE58NBWARFg1AUf0beFKgqj/+KavL0VJU6wtGOwc3Zf0UfgnAOLJnEBmUwExf6rbCBPz2wplzFtOUVDxo8HJ7RM7En2r4qYg9eBnQeeeWvQdB04t89/1O/w1cDnyilFU='
CHANNEL_SECRET = 'c9810af033f3b71c3575127651aa3045'

# === Gemini API Key ===
client = genai.Client(api_key="YOUR_GEMINI_API_KEY")

# === LINE SDK Setup ===
line_bot_api = LineBotApi(CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(CHANNEL_SECRET)

# === Flask Setup ===
app = Flask(__name__)

# === Gemini Function ===
def generate_answer(question):
    prompt_th = (
        f"‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏û‡∏•‡∏á 3 ‡πÄ‡∏û‡∏•‡∏á ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤: '{question}' "
        f"‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô format ‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô (‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏≠‡∏∑‡πà‡∏ô):\n\n"
        f"‡πÄ‡∏û‡∏•‡∏á: <‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á>\n‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: <‡∏™‡∏±‡πâ‡∏ô‡πÜ 1-2 ‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î>\n‡∏•‡∏¥‡∏á‡∏Å‡πå: <‡∏•‡∏¥‡∏á‡∏Å‡πå YouTube>\n\n"
        f"‡∏ó‡∏≥‡πÅ‡∏ö‡∏ö‡∏ô‡∏µ‡πâ 3 ‡∏ä‡∏∏‡∏î ‡∏´‡πâ‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡πÄ‡∏Å‡∏¥‡∏ô ‡πÅ‡∏•‡∏∞‡∏´‡πâ‡∏≤‡∏°‡πÉ‡∏™‡πà prefix ‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡∏∑‡πà‡∏ô‡∏ô‡∏≠‡∏Å‡∏à‡∏≤‡∏Å format ‡∏ô‡∏µ‡πâ"
    )
    prompt_en = (
        f"Recommend 3 songs that match the word: '{question}'. "
        f"Reply in the following format only (do not include anything else):\n\n"
        f"Song: <Song Title>\nReason: <Short explanation (1‚Äì2 lines)>\nLink: <YouTube Link>\n\n"
        f"Do this for 3 songs only. Do not exceed or include any prefix."
    )
    prompt = prompt_th + "\n\n---\n\n" + prompt_en

    response = client.models.generate_content(
        model="gemini-2.0-pro",
        contents=[prompt]
    )
    return response.text

# === Parse Gemini Response ===
def parse_gemini_response(text):
    songs = []
    for block in text.strip().split("\n\n"):
        lines = block.strip().split("\n")
        if len(lines) >= 3:
            title_line = [l for l in lines if "‡πÄ‡∏û‡∏•‡∏á:" in l or "Song:" in l]
            desc_line = [l for l in lines if "‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•:" in l or "Reason:" in l]
            url_line = [l for l in lines if "‡∏•‡∏¥‡∏á‡∏Å‡πå:" in l or "Link:" in l]

            if title_line and desc_line and url_line:
                title = title_line[0].split(":", 1)[1].strip()
                desc = desc_line[0].split(":", 1)[1].strip()
                url = url_line[0].split(":", 1)[1].strip()
                songs.append({"title": title, "desc": desc, "url": url})
    return songs

# === Build Flex Bubble ===
def build_song_bubble(song):
    return {
        "type": "bubble",
        "size": "kilo",
        "body": {
            "type": "box",
            "layout": "vertical",
            "spacing": "md",
            "contents": [
                {
                    "type": "text",
                    "text": song["title"],
                    "weight": "bold",
                    "size": "lg",
                    "wrap": True,
                    "color": "#1DB954"
                },
                {
                    "type": "text",
                    "text": song["desc"],
                    "wrap": True,
                    "size": "sm",
                    "color": "#666666"
                }
            ]
        },
        "footer": {
            "type": "box",
            "layout": "horizontal",
            "contents": [
                {
                    "type": "button",
                    "style": "link",
                    "height": "sm",
                    "action": {
                        "type": "uri",
                        "label": "üîó ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ô YouTube",
                        "uri": song["url"]
                    }
                }
            ]
        }
    }

# === Create Carousel ===
def create_carousel_message(answer_text):
    song_list = parse_gemini_response(answer_text)
    bubbles = [build_song_bubble(song) for song in song_list]

    return FlexSendMessage(
        alt_text="‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏û‡∏•‡∏á",
        contents={
            "type": "carousel",
            "contents": bubbles
        }
    )

# === Handle Message ===
@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    user_message = event.message.text.strip()
    user_id = event.source.user_id

    print(f"Received message: {user_message} from {user_id}")

    greetings = ['‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ', 'hello', 'hi', '‡∏´‡∏ß‡∏±‡∏î‡∏î‡∏µ', '‡πÄ‡∏Æ‡∏•‡πÇ‡∏´‡∏•', '‡πÑ‡∏á']
    if any(greet in user_message.lower() for greet in greetings):
        hour = datetime.now().hour
        if 5 <= hour < 12:
            time_greeting = "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏ï‡∏≠‡∏ô‡πÄ‡∏ä‡πâ‡∏≤‡∏Ñ‡∏£‡∏±‡∏ö ‚òÄÔ∏è"
        elif 12 <= hour < 17:
            time_greeting = "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏ï‡∏≠‡∏ô‡∏ö‡πà‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö üå§"
        elif 17 <= hour < 21:
            time_greeting = "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏ï‡∏≠‡∏ô‡πÄ‡∏¢‡πá‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö üåá"
        else:
            time_greeting = "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏ï‡∏≠‡∏ô‡∏Å‡∏•‡∏≤‡∏á‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö üåô"

        intro_options = [
            "‡∏ú‡∏°‡∏Ñ‡∏∑‡∏≠‡∏ö‡∏≠‡∏ó‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏û‡∏•‡∏á üéß",
            "‡∏ú‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏≠‡∏≤‡∏£‡∏°‡∏ì‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏Ñ‡∏£‡∏±‡∏ö üé∂",
            "‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡∏™‡∏∂‡∏Å‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏°‡∏≤ ‡πÅ‡∏•‡πâ‡∏ß‡∏ú‡∏°‡∏à‡∏∞‡∏´‡∏≤‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏≠‡∏á‡∏Ñ‡∏£‡∏±‡∏ö üòä",
            "‡∏≠‡∏¢‡∏≤‡∏Å‡∏ü‡∏±‡∏á‡πÄ‡∏û‡∏•‡∏á‡πÅ‡∏ô‡∏ß‡πÑ‡∏´‡∏ô ‡∏ö‡∏≠‡∏Å‡∏ú‡∏°‡∏°‡∏≤‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö üéº"
        ]
        intro = random.choice(intro_options)

        reply_text = f"{time_greeting}\n{intro}"
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply_text))
        return

    # ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏Ñ‡∏≥‡∏ó‡∏±‡∏Å‡∏ó‡∏≤‡∏¢ ‚Üí ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏´‡∏≤‡πÄ‡∏û‡∏•‡∏á
    try:
        answer = generate_answer(user_message)
        print("Gemini raw response:\n", answer)

        flex_msg = create_carousel_message(answer)
        line_bot_api.reply_message(event.reply_token, flex_msg)
    except Exception as e:
        print("Error:", e)
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(text="‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡∏ö‡∏≠‡∏ó‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ üò¢")
        )

# === Webhook Endpoint ===
@app.route("/callback", methods=['POST'])
def callback():
    signature = request.headers['X-Line-Signature']
    body = request.get_data(as_text=True)

    try:
        handler.handle(body, signature)
    except Exception as e:
        print("Error in webhook:", e)
        abort(400)

    return 'OK'

# === Main ===
if __name__ == "__main__":
    app.run(host='0.0.0.0', port=5000)
